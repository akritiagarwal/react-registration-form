'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createDataLoader = createDataLoader;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _util = require('./util');

/**
 * A wrapper for a React component that manages the data fetching from LoopBack
 * server automatically. The wrapped component will receive the `DataLoader`
 * instance as `dataloader` property. And, for each query, two extra parameters
 * will be passed:
 *
 * - `{name}` → The data received from LoopBack API
 * - `{name}_status` → A string that can have the following values:
 *   - `'loading'` → When new data is currently being loaded;
 *   - `'ok'` → When data was correctly loaded;
 *   - `'error: {error_message}'` → When an error occurs.
 *
 * The options object:
 *
 * ```javascript
 * {
 *  extendMethods: [           // (Optional) Array of component methods that
 *    'method_a'               // should still be available on wrapper
 *  ],
 *
 *  queries: [                 // (Required) Array of queries to be made
 *    {
 *      name: 'todo',          // (Optional: defaults to endpoint value)
 *                             // The name of the property passed to Component
 *                             // that will contain the fetched data
 *
 *      endpoint: 'tasks',     // (Required) The endpoint on Loopback server
 *
 *      filter: {              // (Optional / object or function)
 *        where: {done: false} // The filter object passed to Loopback API
 *      },
 *
 *      filter: function (params) {       // function version of filter
 *        if (!params.page) return false;
 *        return {
 *          limit: 30,
 *          skip: 30 * params.page - 30
 *        };
 *      },
 *
 *      params: {              // (Optional) Default parameters passed to
 *        page: 1              // filter function
 *      },
 *
 *      autoLoad: true,        // When true (default), query will be fetched as
 *                             // soon as the component is mounted
 *
 *      transform: 'array',    // Transform function that will receive new data
 *                             // and return the data passed to inner component.
 *                             // When equal to 'array' (default), the data is
 *                             // kept as an array of objects.
 *                             // When equal to 'object', the data is kept as a
 *                             // key-value object, where key is the id field.
 *                             // You can pass a custom function as well.
 *
 *      transform: function (json, data, filter, params, options) {
 *                             // Parameters:
 *                             // json: The new data from LoopBack API
 *                             // data: The existent data
 *                             // filter: The filter object used to request data
 *                             // params: The params object passed to filter function
 *                             // options: The options object passed to load method
 *                             //
 *                             // Is recommended that you don't modify the data
 *                             // parameter. Instead create and return a new
 *                             // object.
 *      }
 *    },
 *    { ... }
 *  ]
 * }
 * ```
 *
 * @param  {React.Component} Component The React component that will receive the
 *                                     fetched data
 * @param  {object}          options   The options object
 * @return {DataLoader}                The DataLoader wrapper component
 */

function createDataLoader(Component) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (!Component) {
    throw new Error('Component is required');
  }

  if (!options.queries) {
    throw new Error('options.queries is required');
  }

  var spec = {
    statics: {
      /**
       * Get baseUrl from config and make sure there is a slash at the end.
       * @return {string} The API base URL
       */
      _getBaseUrl: function _getBaseUrl() {
        var baseUrl = _config2['default'].get('baseUrl') || '';
        if (baseUrl.slice(-1) !== '/') {
          baseUrl += '/';
        }
        return baseUrl;
      },

      /**
       * Given the endpoint and its filter, this will build the full
       * URL to query Loopback
       * @param  {string} endpoint Name of the route
       * @param  {object} filter   Filter object
       * @return {string}          Loopback URL
       */
      _buildUrl: function _buildUrl(endpoint, filter) {
        var baseUrl = DataLoader._getBaseUrl();
        var url = baseUrl + endpoint;
        if (filter) {
          url += '?filter=' + encodeURIComponent(JSON.stringify(filter));
        }
        var token = _config2['default'].get('access_token') || '';
        if (token) {
          url += filter ? '&' : '?';
          url += 'access_token=' + token;
        }
        return url;
      },

      /**
       * Normalizes the queries objects.
       * @param  {array} queries Array of queries objects
       * @return {array}         Array of normalized queries objects
       */
      _normalizeQueries: function _normalizeQueries(queries) {
        var _this = this;

        return queries.map(function (_ref) {
          var name = _ref.name;
          var filter = _ref.filter;
          var endpoint = _ref.endpoint;
          var _ref$params = _ref.params;
          var params = _ref$params === undefined ? {} : _ref$params;
          var _ref$autoLoad = _ref.autoLoad;
          var autoLoad = _ref$autoLoad === undefined ? true : _ref$autoLoad;
          var _ref$transform = _ref.transform;
          var transform = _ref$transform === undefined ? 'array' : _ref$transform;

          // Remove leading slash
          if (endpoint.slice(0, 1) === '/') {
            endpoint = endpoint.slice(1);
          }
          // Remove trailing slash
          if (endpoint.slice(-1) === '/') {
            endpoint = endpoint.slice(0, -1);
          }

          if (typeof transform === 'string') {
            transform = _this['_transform_' + transform];
          }
          if (typeof transform !== 'function') {
            throw new Error('Unknown type of transform option:' + typeof transform);
          }

          name = name || endpoint.replace(/\W+/g, '-');

          return {
            name: name,
            filter: filter,
            endpoint: endpoint,
            params: params,
            autoLoad: autoLoad,
            transform: transform
          };
        });
      },

      /**
       * Transform function that keeps data as array, optionally concatening new
       * results.
       * @param  {array}  json    JSON data received from LoopBack API
       * @param  {array}  data    Previouly received data
       * @param  {object} filter  Filter object used to query LoopBack API
       * @param  {object} params  Params object passed to filter function
       * @param  {object} options Options object passed to load method
       * @return {array}          The resulting array that inner component will
       *                          receive
       */
      _transform_array: function _transform_array(json, data, filter, params, _ref2) {
        var _ref2$append = _ref2.append;
        var append = _ref2$append === undefined ? false : _ref2$append;

        return append ? data.concat(json) : json;
      },

      /**
       * Transform function that keeps data as a key-value object, where key is
       * the id of the row and value is the row.
       * @param  {array}  json    JSON data received from LoopBack API
       * @param  {array}  data    Previouly received data
       * @param  {object} filter  Filter object used to query LoopBack API
       * @param  {object} params  Params object passed to filter function
       * @param  {object} options Options object passed to load method
       * @return {object}         The resulting object that inner component will
       *                          receive
       */
      _transform_object: function _transform_object(json, data, filter, params, _ref3) {
        var _ref3$id = _ref3.id;
        var id = _ref3$id === undefined ? 'id' : _ref3$id;
        var _ref3$reset = _ref3.reset;
        var reset = _ref3$reset === undefined ? false : _ref3$reset;

        var newData = _.indexBy(json, id);
        if (reset) {
          return newData;
        }
        return _.assign({}, data, newData);
      }
    },

    /**
     * Data fetching is started as soon as possible
     */
    componentWillMount: function componentWillMount() {
      var _this2 = this;

      // creates internal structures
      this._queries = _.indexBy(DataLoader._normalizeQueries(options.queries), 'name');
      this._data = _(this._queries).map(function (q) {
        return [q.name, []];
      }).zipObject().value();

      // creates a debounced version of load function for each query
      this._queries = _.mapValues(this._queries, function (q) {
        return _extends({}, q, {
          load: (0, _util.debounce)(function (options) {
            return _this2._load(q.name, options);
          }, 200, false)
        });
      });

      // autoload, if allowed
      _.map(this._queries, function (_ref4) {
        var name = _ref4.name;
        var autoLoad = _ref4.autoLoad;
        return autoLoad && _this2.load(name);
      });
    },

    /**
     * Loads data from LoopBack API. Receives the name of the query to be used, the
     * aditional parameters to pass to filter function (if existent) and a options
     * object:
     *
     * ```
     * {
     *   resetParams: false, // When true, previous parameters will be replaced.
     *                       // When false (default), they will be merged.
     *
     *   append: false       // (used only with 'array' transform function)
     *                       // When true, new data will be appended to the old data.
     *                       // When false (default), new data will replace old data.
     *
     *   id: 'id'            // (used only with 'object' transform function)
     *                       // The name of id field to be used as key
      *   reset: false        // (used only with 'object' transform function)
     *                       // When true, the new data will replace old data.
     * }
     * ```
     *
     * @param  {string} name    The name of the query to load
     * @param  {object} params  Parameters to be passed to filter function, if existent
     * @param  {object} options Options object
     */
    load: function load(name) {
      var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var cfg = this._queries[name];

      if (options.resetParams) {
        cfg.params = {};
      }

      _.assign(cfg.params, params);

      cfg.load(options);
    },

    _load: function _load(name, options) {
      var _this3 = this;

      var cfg = this._queries[name];

      var filter = typeof cfg.filter === 'function' ? cfg.filter(cfg.params) : cfg.filter;

      if (filter === false) {
        return;
      }

      var url = DataLoader._buildUrl(cfg.endpoint, filter);

      var status = cfg.name + '_status';
      this._data[status] = 'loading';
      this.forceUpdate();

      fetch(url).then(function (response) {
        if (!response.ok) throw new Error(response.statusText);
        return response.json();
      }).then(function (json) {
        _this3._data[cfg.name] = cfg.transform(json, _this3._data[cfg.name], filter, cfg.params, options);
      }).then(function () {
        return _this3._data[status] = 'ok';
      }, function (err) {
        return _this3._data[status] = 'error: ' + err.message;
      }).then(function () {
        return _this3.forceUpdate();
      });
    },

    render: function render() {
      return _react2['default'].createElement(Component, _extends({
        ref: 'component',
        dataloader: this
      }, this.props, this._data));
    }
  };

  /**
   * Create the methods of inner component directly on wrapper
   */
  var _options$extendMethods = options.extendMethods;
  var extendMethods = _options$extendMethods === undefined ? [] : _options$extendMethods;

  extendMethods.forEach(function (methodName) {
    spec[methodName] = function () {
      var _refs$component;

      return (_refs$component = this.refs.component)[methodName].apply(_refs$component, arguments);
    };
  });

  /**
   * The wrapper component that will manage the data fetching. It is the return
   * value of the `createDataLoader` function and the value of `dataloader`
   * property of wrapped component.
   */
  var DataLoader = _react2['default'].createClass(spec);

  return DataLoader;
}